> 部分内容来自《深入理解Java虚拟机第二版》。

一. **线程安全**
1.现实中的对象在一项工作进行期间，会被不断地中断和切换，对象的属性（数据）可能会在中断期间被修改和变脏，而这些事件在计算机世界则是很正常的事情。对于这  
部分的主题“高效并发”来讲，首先需要保证并发的正确性，然后在此基础上实现高效。  
2.定义：当多个线程访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方进行任何其他的协调操作，调用  
这么对象的行为都可以获得正确的结果，那这个对象是线程安全的。  
二.**Java语言中的线程安全**  
1.**不可变**。   
    Java语言中，如果共享数据是一个基本数据类型，那么只要在定义时使用final关键字修饰它就可以保证它是不可变的。如果共享变量是一个对象，那就需要保证对象  
的行为不会对其状态产生任何影响才行。例如String对象是一个典型的不可变对象，我们调用它的substring(),replace()和concat()这些方法不会影响他原来的值，只  
会返回一个新构造的字符串对象。保证对象不可变，可以将对象中所有带有状态的变量都声明为final，这样在构造函数结束之后，该对象就是不可变的。  
2.**绝对线程安全**。   
    一个类要达到“不管运行时环境如何，调用者都不需要任何额外的同步措施”通常需要付出很大的，甚至有时候是不切实际的代价。在JavaAPI中标注自己是线程安全的  
类，大多数都不是绝对的线程安全。  
3.**相对线程安全**。   
    相对的线程安全即使我们通常意义上所讲的线程安全，他需要保证这个对象单独的操作是线程安全的，我们在调用的时候不需要做额外的保障措施，但是对于一些特定  
顺序的连续调用，就可能需要在调用端使用额外的同步手段来保证调用的正确性。**在Java语言中，大部分的线程安全类都属于这种类型**，例如Vector，HashTable，  
Collections的synchronizedCollection()方法包装的集合等。  
4.**线程兼容**  
    线程兼容是指对象本身并不是线程安全的，但是可以通过调用端正确地使用同步手段来保证对象在并发环境中可以安全地使用，我们平常所说的一个类不是线程安全的，  
绝大多数是指这一种情况。  
5.**线程对立**  
    线程对立是指无论调用端是否采用了同步措施，都无法在多线程环境中并发使用的代码。一个线程对立的例子是Thread类的suspend()和resume()方法,如果有两个线  
程同时持有一个线程对象，一个尝试去中断线程，另一个尝试去恢复线程，如果并发进行的话，无论调用者是否进行了同步，目标线程都是存在死锁风险的。也正因如此,  
suspend()和resume()已经被JDK声明为(@Deprecated)了。常见的线程对立的还有System.setIn()、System.setOut()和System.runFinalizersOnExit()等。  
三.**线程安全的实现方法**  
1.**互斥同步**  
    互斥同步是常见的一种并发正确性保障手段。同步是指在多个线程并发访问共享数据时，保障共享数据在同一时刻只被一个(或者是一些，使用信号量的时候)线程使用。  
而互斥是实现同步的一种手段，**临界区、互斥量和信号量都是主要的互斥实现方式**。因此，在这4个字里面，互斥是因，同步是果；互斥是方法，同步是目的。  
    在Java中，最基本的互斥同步手段就是synchronized关键字，**synchronized关键字经过编译之后，会在同步块的前后分别形成monitorenter和monitorexit这两  
个字节码指令**，这两个字节码都需要一个reference类型的参数来指明要锁定和解锁的对象。如果Java程序中的synchronized明确指定了对象参数,那就是这个对象的  
reference；如果没有明确指定，那就根据synchronized修饰的是实例方法还是类方法，去取对应的对象实例或Class对象来作为锁对象。  
    在执行monitorenter指令时，首先要尝试获取对象的锁。如果这个对象没被锁定，或者当前线程已经拥有了那个对象的锁，把锁的计数器加1，相应的，在执行  
monitorexit指令时会将锁计数器减1,当计数器为0时,锁就被释放.如果获取对象锁失败,那当前线程就要阻塞等待,直到对象锁被另一个线程释放为止.并且,synchronized  
同步块对**同一条线程来说是可重入**的，不会出现自己把自己锁死的问题。其次，同步块在已进入的线程执行之前，会阻塞后面其他线程的进入。**Java的线程是映射到  
操作系统的原生线程之上的，如果要阻塞或唤醒一个线程，都需要操作系统来帮忙完成，这就需要从用户态转换到核心态中，因此状态转换需要耗费很多的处理器时间**.对  
于代码简单的同步块（如被synchronized修饰的getter()或setter()方法）,状态转换消耗的时间有可能比用户代码执行的时间还要长.所以synchronized是Java语言的  
一个**重量级**(Heavyweight)的操作，而虚拟机本身也会进行一些优化，譬如在通知操作系统阻塞线程之前加入一段自旋等待过程，避免频繁地切入到核心态中。  
    除了synchronized之外,我们还可以使用java.util.concurrent(JUC)包中的重入锁(ReentrantLock)来实现同步,在基本用法上,ReentrantLock与synchronized  
很相似，他们都具备一样的线程重入特性，只是代码写法上有点区别，一个表现为API层面的互斥锁(lock()和unlock()方法配合try/finally语句块来完成)，另一个表现    
为原生语法层面的互斥锁。不过，相比synchronized，ReentrantLock增加了一些高级功能，主要有以下3项：等待可中断，可实现公平锁，以及锁可以绑定多个条件。  
    JDK1.6发布后，人们就发现synchronized与ReentrantLock的性能基本持平了。虚拟机在未来的性能改进中肯定也会更加偏向于原生的synchronized,所以还是提倡  
在synchronized能实现需求的情况下，优先考虑使用synchronized来进行同步。  
2.**非阻塞同步**  
    从处理的角度来说，互斥同步是一种悲观的并发策略，总是认为只要不去做正确的同步措施（如加锁），那就肯定会出现问题,无论共享数据是否真的会出现竞争,他都  
要进行加锁（实际上虚拟机会优化掉很大部分不需要的加锁）、用户态核心态转换、维护锁计数器和检查是否有被阻塞的线程需要唤醒等操作。随着硬件指令集的发展,我们  
有了另外一个选择：基于冲突检测的乐观并发策略，通俗地讲，就是先进行操作，如果没有其他线程争用共享数据,那操作就成功了；如果共享数据有争用,产生了冲突,那就  
再采取其他的补偿措施（最常见的补偿措施就是不断的重试，直至成功），这种乐观的并发策略的许多实现都不需要把线程挂起，因此这种同步操作称为非阻塞同步  
(Non-Blocking Synchronization)。  
    在Jdk1.5之后，Java程序中才可以使用CAS操作。尽管CAS看起来要比阻塞操作要完美，但显然这种操作无法涵盖互斥同步的所有使用场景,并且CAS从语义上来说并不  
是完美的，存在这样的一个逻辑漏洞：如果一个变量V初次读取的时候是A值,并且在准备赋值的时候检查到它仍为A值,那我们就说他的值没有被其他线程改变了吗?如果这段  
时间他的值曾经被改成了B，后来又被改回为A，那CAS操作就会误认为他从来没有被改变过。这个漏洞称为**CAS操作的**“**ABA**”**问题**。**JUC包为了解决这个问题，  
提供了一个带有标记的原子引用类“AtomicStampedReference”，他可以通过控制变量值的版本号来保证CAS的正确性**。大部分情况下ABA问题不会影响程序并发的正确性，  
如果需要解决ABA问题，改用传统的互斥同步可能会比原子类更加高效。
3.**无同步方案**  
    同步只是保证共享数据争用的正确性的手段，如果一个方法本来就不涉及共享数据，那他自然就无需任何同步措施去保证正确性。以下是两种常见的天生就代码安全的  
情况：
    3.1.**可重入代码** 
    这种代码也叫**纯代码**，可以在代码执行的任何时刻去中断它，转而去执行另外一段代码（包括递归调用它本身），而在控制权返回后，原来的程序不会出现任何错  
误。
    可重入代码有一些共同的特征，例如**不依赖存储在堆上数据和公用的系统资源，用到的状态量都由参数中传入、不调用非可重入的方法等**。我们可以通过一个简单  
的原则来判断代码是否具备可重入性：**如果一个方法，他的返回结果是可以预测的，只要输入了相同的数据，就能返回相同的结果，那他就满足可重入性，当然也是线程安全的**。
    3.2.**线程本地存储**  
    其中一个重要的应用实例是经典WEB交互模型中“一个请求对应一个服务器进程”(Thread-per-Request)的处理方式，这种处理方式的广泛应用使得很多web服务端应用  
都可以使用线程本地存储来解决线程安全问题。  
    Java语言中，如果一个变量要被多线程访问，可以使用volatile关键字声明它为“易变的”。**每一个线程的Thread对象中都有一个ThreadLocalMap对象，这个对象  
存储了一组以ThreadLocal.threadLocalHashCode为键，以本地线程变量为值的K-V值对**，ThreadLocal对象就是当前线程的ThreadLocalMap的访问入口，没一个ThreadLocal对象都包含了一个独一无二的threadLocalHashCode值，使用这个值就可以在线程K-V值对中找到对应的本地线程变量。
  
四. **锁优化**  
    1.**自旋锁与自适应自旋**  
    **互斥同步对性能最大的影响是阻塞的实现，挂起线程和恢复线程的操作都需要转入到内核态中完成，这些操作给系统的并发性能带来了很大的压力**。如果物理机器  
有一个以上的处理器，能让两个或以上的线程同时并行执行，我们就可以让后面请求锁的哪个线程“稍等一下”，但不放弃处理器的执行时间，看看持有锁的线程是否会很快  
就释放锁。为了让线程等待，我们只需让线程执行一个循环(自旋)，这项技术就是所谓的自旋锁。  
    自旋等待不能代替阻塞，自旋等待本身虽然避免了线程切换的开销。但他是要占用处理器时间的。因此，如果锁被占用的时间很短，自旋等待的效果就会非常好,反之,  
如果锁被占用的时间很长，那么自旋的线程只会白白消耗处理器资源，而不会做任何有用的工作，反而会带来性能上的浪费，因此，自旋等待的时间必须有一定的限度,如果  
自旋超过了限定次数仍然没有成功获得锁，就应当使用传统的方式去挂起线程了。  
    在JDK1.6中引入了自适应的自旋锁。自适应意味着自旋的事件不再固定了，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。如果线程刚刚获得锁，  
那么虚拟机会认为这次自旋也很有可能再次成功，进而它允许自旋等待持续相对更长的时间。如果自旋很少成功过，那在以后要获取这个锁时将可能省略掉自旋过程,以避免浪  
费处理器资源。  
    2.**锁消除**  
    锁消除是指虚拟机即时编译器在运行时，对一些代码上要求同步，但是被检测到不可能存在共享数据竞争的锁进行消除。**锁消除的主要判定依据来源于逃逸分析的数  
据支持**，如果判断在一段代码中，堆上的所有数据都不会逃逸出去从而被其他线程访问到，那就可以把它们当做栈上数据对待，认为他们是线程私有的，同步加锁自然就  
无须进行。
    3.**锁粗化**  
    如果一系列的连续操作都对同一个对象反复加锁与解锁，甚至加锁操作是出现在循环体中的，那即使没有线程竞争,频繁进行互斥同步操作也会导致不必要的性能消耗。  
    **如果虚拟机探测到有这样一串零碎的操作都对同一个对象进行加锁，将会把加锁同步的范围拓展(粗化)到整个操作序列的外部**。  
    4.**轻量级锁**  
    “轻量级”是相对于使用操作系统互斥量来实现的传统锁而言的，因此传统的锁机制就称为“重量级”。要强调一点的是，**轻量级锁并不是用来代替重量级锁的，它的本  
意实在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗**。  
    HotSpot虚拟机的**对象头(Object Header)分为两部分信息,第一部分用于存储自身的运行时数据,如哈希码(HashCode)、GC分代年龄(Generational GC age)等**，  
这部分数据的长度在32位和64位的虚拟机中分别为32bit和64bit，官方称它为**“Mark Word”，它是实现轻量级锁与偏向锁的关键**。**另外一部分用于存储指向方法区  
对象类型数据的指针。如果是数组对象的话，还会有一个额外的部分用于存储数组长度**。  
    轻量级锁能提升程序同步性能的依据是“对于绝大部分的锁，在整个同步周期内都是不存在竞争的”。**如果没有竞争，轻量级锁使用CAS操作避免了使用互斥量的开销，  
但如果存在竞争，除了互斥量的开销外，还额外发生了CAS操作，因此在有竞争的情况下，轻量级锁会比传统的重量级锁更慢**。  
    5.**偏向锁**  
    **偏向锁**也是JDK1.6中引入的一项锁优化，他的**目的是消除数据在无竞争情况下的同步原语，进一步提升程序的运行性能.如果说轻量级锁是在无竞争的情况下使  
用CAS操作去消除同步使用的互斥量，那偏向锁就是在无竞争的情况下把整个同步都消除掉，连CAS操作都不做了**。  
    偏向锁会偏向于第一个获得他的线程，如果在接下来的执行过程中，该所没有被其他线程获取，则持有偏向锁的线程将永远不需要再进行同步操作。  
    **偏向锁可以提高同步但无竞争的程序性能**。它同样是一个带有效益权衡(Trade Off)性质的优化，也就是说，它**并不一定总是对线程运行有利，如果程序中大多  
数的锁总是被多个不同的线程访问，那偏向锁是多余的**。  
    6.常见的锁升级的过程：  
    **无锁 => 偏向锁 => 轻量级锁 => 重量级锁**  
    
    
    
