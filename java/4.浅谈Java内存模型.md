**一.概述：**  
    衡量一个服务性能的高低好坏，每秒事务处理数（Transactions Per Seconds，TPS）是最重要的指标之一，它代表着一秒内服务端平均能响应的请求总数，而TPS值与
程序的并发能力又有非常密切的关系。对于计算量相同的任务，程序线程并发协调得越有条不紊，效率自然就会越高；反之，线程之间频繁阻塞甚至死锁，将会大大降低程序
的并发能力。注意，Java的内存模型要与Java的内存结构相区分开，前者与Java并发编程有关，后者与与JVM中内存结构划分有关，注意区分这两个概念。基于高速缓存的存
储交互很好地解决了处理器与内存的速度与矛盾，但是也为计算机系统带来更高的复杂度，因为他引入了一个新的问题：缓存一致性。   

**二.Java内存模型：**  
    Java虚拟机规范中试图定义一种Java内存模型（Java Memory Model，JMM）来屏蔽掉各种硬件和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一
致的内存访问效果。  
1. **主内存与工作内存**：  
    Java内存模型的主要目标是定义程序中各个变量的访问规则，即在虚拟机中将变量存储到内存和从内存中取出变量这样的底层细节。此处的**变量包含了实例字段、静态
字段和构成数组对象的元素。但不包括局部变量与方法参数，因为后者是线程私有的，不会被共享，自然就不会存在竞争问题**。  
    **每条线程还有自己的工作内存**，线程的工作内存保存了被该线程使用到的变量的主内存副本拷贝，**线程对变量的所有操作（读取，赋值等）都必须在工作内存中进
行，而不能直接读写主内存中的变量。不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量值的传递均需要通过主内存来完成**。
2.**对于volatile型变量的特殊规则**：    
    当一个变量定义为**volatile**之后，他将具备两种特性，**第一是保证该变量对所有线程的可见性**，这里的“可见性”是指当一条线程修改了这个变量的值，新值对于
其他线程来说是可以立即得知的。volatile变量在各个线程的工作内存中不存在一致性的问题，但是在java里边的运算并非原子操作，导致volatile变量的运算在并发下是不
安全的。由于volatile变量只保证可见性，在不符合以下两条规则的运算规则中，我们仍然要通过加锁（synchronized 或 java.util.concurrent中的原子类）来保证原子
性：一是运算结果并不依赖变量的当前值，或者能够确保只有单一的线程修改变量的值，二是变量不需要与其他的状态变量共同参与不变约束。  
    使用volatile变量的**第二个语义是禁止指令重排优化**，普通的变量仅仅会保证在该方法的执行过程中所有依赖赋值结果的地方都能够获取到正确的结果，而不能保证
变量赋值操作的顺序与程序代码的执行顺序一致。因为在一个线程的方法执行过程中无法感知到这点，这也就是Java内存模型中描述的所谓的“线程内表现为串行的语义”。  
    **volatile**变量读操作的性能消耗与普通变量几乎没有多大差别，但是写操作则可能会慢一些，因为它**需要在本地代码中插入许多内存屏障指令来保证处理器不发生乱序执行**。不过即便如此，大多数场景下volatile的总开销仍然要比锁低，我们在volatile与锁之间选择的唯一依据仅仅是volatile的语义是否能够满足使用场景的需求。  
3.一些关键字：  
    除了volatile之外，Java还有两个关键字能实现可见性，即synchronized和final。  
    Java语言提供了volatile和synchronized两个关键字来保证线程之间操作的有序性，volatile关键字本身就包含了禁止指令重排序的语义，而synchronized则是由“一
个变量在同一个时刻只允许一条线程对其进行lock操作”这条规则获得的，这条规则决定了持有同一个锁的两个同步块只能串行地进入。  
4.**先行发生原则**：  
    先行发生是Java内存模型中定义的两项操作之间的偏序关系，如果说操作A先行发生于操作B，其实就是说在发生操作B之前，操作A产生的影响能被操作B观察到，“影响”
包括修改了内存中共享变量的值，发送了消息，调用了方法等。时间的先后顺序与先行发生原则并没有太大的关系，所以我们**衡量并发安全问题的时候**不要受到时间顺序
的干扰，**一切必须以先行发生原则为准**。    
**三.Java与线程**  
    线程是比进程更轻量级的调度执行单位，线程的引入，可以把一个进程的资源分配和执行调度分开，各个线程既可以共享进程资源（内存地址、文件I/O等），又可以
独立调度（**线程是CPU调度的基本单位**）。  
    实现线程主要有3种方式：使用内核线程实现、使用用户线程实现和使用用户线程加轻量级进程混合实现。轻量级进程就是我们通常意义上所讲的线程。
    对于Sun JDK来说，它的Windows版与Linux版都是使用一对一的线程模型实现的，一条Java线程就映射到一条轻量级进程之中，因为Windows和Linux系统提供的线
程模型就是一对一的。   
    **Java使用的线程调度方式就是抢占式调度**。虽然Java线程调度是系统自动完成的，但是我们还是可以“建议”系统给多分配一点执行时间，另外的一些线程则可
以多分配一点--这项操作可以通过设置线程优先级来完成。Java语言一共设置了10个级别的线程优先级（Thread.MIN_PRIORITY至Thread.MAX_PRIORITY）,**在两个
线程同时处于Ready转态时，优先级越高的线程越容易被系统选择执行**。   
    转态转换：   
    Java语言定义了5种线程转态：  
    1.**新建**；  
    2.**运行**；  
    3.**等待**（无限期等待/限期等待）；  
    4.**阻塞**；  
    5.**结束**。  
